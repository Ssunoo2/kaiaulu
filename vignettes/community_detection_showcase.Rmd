---
title: "Community Detection Showcase"
output: 
  html_document:
    toc: true
    number_sections: true
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Community Detection Showcase}
  %\VignetteEncoding{UTF-8}
---


```{r}
rm(list = ls())
seed <- 1
set.seed(seed)
```

```{r warning=FALSE,message=FALSE}
require(kaiaulu)
require(visNetwork)
require(reactable)
require(data.table)
require(igraph)
require(yaml)
require(stringi)
require(knitr)
```

# Project Configuration File 

Load config file.

```{r}
tool <- yaml::read_yaml("../tools.yml")
conf <- yaml::read_yaml("../conf/apr.yml")

# 3rd Party Tools
perceval_path <- tool[["perceval"]]
utags_path <- tool[["utags"]]
oslom_dir_path <- tool[["oslom_dir"]]
oslom_undir_path <- tool[["oslom_undir"]]

# Ctags Line Types
kinds <- conf[["tool"]][["uctags"]][["keep_lines_type"]]

# Local Git Repo Folder Path
git_repo_path <- conf[["data_path"]][["git"]]

# File Filters
file_extensions <- conf[["filter"]][["keep_filepaths_ending_with"]]
substring_filepath <- conf[["filter"]][["remove_filepaths_containing"]]
```

# Parse Git Log

```{r}
project_git <- parse_gitlog(perceval_path,git_repo_path)
project_git <- project_git  %>%
  filter_by_file_extension(file_extensions,"file_pathname")  %>% 
  filter_by_filepath_substring(substring_filepath,"file_pathname")
```

```{r}
project_git$author_datetimetz <- as.POSIXct(project_git$author_datetimetz,
                                              format = "%a %b %d %H:%M:%S %Y %z", tz = "UTC")
project_git$author_datetimetz <- as.POSIXct(project_git$committer_datetimetz,
                                              format = "%a %b %d %H:%M:%S %Y %z", tz = "UTC")

project_git_slice <- project_git[author_datetimetz >= as.POSIXct("2015-03-01", format = "%Y-%m-%d",tz = "UTC") & author_datetimetz < as.POSIXct("2015-03-31", format = "%Y-%m-%d",tz = "UTC")]
```

# Identity Matching 

```{r}
project_log <- list(project_git=project_git)
project_log <- identity_match(project_log,
                              name_column = c("author_name_email"),
                              assign_exact_identity,
                              use_name_only=TRUE,
                              label = "raw_name"
                              )
project_git <- project_log[["project_git"]]
```

```{r eval = FALSE}
all_name_emails <- unique(project_git_slice$data.Author)
name_mapping <- data.table(raw_name=all_name_emails,
                           identity_id=assign_exact_identity(all_name_emails,
                                                             use_name_only = FALSE))
project_git_slice <- merge(project_git_slice,name_mapping,
                            by.x="data.Author",by.y="raw_name",all.x = TRUE)
name_mapping <- name_mapping[,.(raw_name = stri_c(raw_name,collapse = " | ")),
             by="identity_id"]
project_git_slice <- merge(project_git_slice,name_mapping,
                            by.x="identity_id",by.y="identity_id",all.x = TRUE)
project_git_slice[,data.Author:=identity_id]
#project_git_slice[,data.Author:=raw_name]
```

# Create Network

```{r}
project_collaboration_network <- transform_gitlog_to_bipartite_network(project_git_slice,mode="author-file")
```

# Community Detection

Use `oslom_dir_path` or `oslom_undir_path` as preferred for directed or undirected
 community detection.

```{r}
 
community <- community_oslom(oslom_undir_path,
              project_collaboration_network[["edgelist"]],
              seed=seed,
              n_runs = 100,
              is_weighted = TRUE)
community
```

